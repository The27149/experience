1. 算法思想汇总：核心：分而治之，化整为零，化繁为简（包括时间空间），  缓存，递归，贪心局部最优。相似的功能块抽象为类；区分对象的相同与不同；
  解决问题思路：对于一般性的抽象问题，可以先从特殊解出发简化问题，掌握规律后，再回归一般。即 一般=>特殊=>一般
2. 抽象类与接口分别： 使用上是否支持多继承等。更核心的是设计目的区别：抽象类为了避免重复代码； 接口是为了体现约束关系；
3. 同一对象复杂功能的实现，不要深层次的继承。拆分为子组件，用零件挂载实现更好。
4. 模块之间不要有很明显的引用关系，防止复用模块或改名改路径时，导致引用报错
5. 全局对象有创建，一定要有销毁。对象完整生命周期管理，对全局有影响的操作 例如：定时器， requestAnimationFrame，事件监听等，都要考虑不用时的移除。
6. 不管数据结构，逻辑关系，一定要剪除任何多余的，没有用到的，摩棱两可的，可有可无的东西，即使现在没有问题，将来扩展时一定会出问题；
7. 设计任何一个类 结构 东西时。都不应该把它设置的太孤立了，不要唯一性。要随时可以创造出与之平级的兄弟元素。就是说设计不能太死了，将来有可能有类似的模块。（这条只是感觉，现在没有具体说明）
8. https://blog.csdn.net/weixin_40121676/article/details/105717756?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai
9. 数据管理经验：对于复杂的对象数组数据类型，可能在多个地方需要使用，如果直接对其引用，会让管理混乱，可能在不知道的地方对原始值进行了修改；如果直接拷贝后，又会有多个备份不能及时同步的风险；正确做法应该时，在一个地方保存，然后利用简单类型（number,string）作为数据特征加到单条数据中，通过get**方法获取。
10. 装饰器是对原先的 类 属性 方法 的扩展，在装饰 类 上面为了能缓解继承的复杂度，没必要已扩展就继承，可能导致层级太深。
11. 设计结构种的通信标准：总体来说，相互独立性较强的模块之间使用事件通信，完全解耦。模块内部联系较强，可以用回调，父子组件，或者功能组件种依赖原则应该顺其自然为，具体依赖抽象，子组件依赖父组件，内部依赖外部，因为真正运行时的主动权的都是最末端，最具体的功能。越往上层越要兼顾的更多，所以整体不可能去绑定某个具体部分，整体，外层，抽象的更像是指定约束，或是工具引用。
12. 前端ui显示流程，为了更清晰的分开视图和数据，应设计为分两步进行，第一步将不依赖数据静态内容加载渲染出来，相当于有一个ui骨架，完成后派发出一个时间节点，ui加载完成，同时发起数据请求，收到相应后，使用对应的数据刷新ui。
13. 框架和库的对比：最主要是控制权的归属。框架要想灵活一点： 插件，配置，生命周期钩子，依赖注入，继承。
14. 一个完整的前端ui显示所有部分，按流程顺序：服务器数据，公共配置，私有配置， 资源加载，初始化，业务。
15. 父子模块的关系和平级模块间的关系是不一样的。平级模块之间互相完全独立平等，使用事件通信没有问题。父子模块实际上是内部分区，并不需要完全解耦。所有的控制权和入口应该全部在父模块中，并管理子模块的生命周期，准确来说这不叫分模块，应该叫同一模块的代码分块。而独立的一个模块相当于一个小项目，也要有统一的入口和管理。
16. 什么时候用事件通信，什么时候直接引用强耦合呢。要看通信的两部分是不是功能紧密。需要完全特指通信的两部分千万不能用事件，因为事件是普适的，完全未知对方的，完全不相关的两部分通信。对于我就要给特定对象发送信息，就应该直接引用它。保证消息不会传偏或者被其他东西影响。
17. 即使是前端，所有的逻辑不能依赖ui来控制，也可以说主动权永远不能全盘交给ui，因为ui的表现太繁杂多变了，还可以有延迟渲染，ui隐藏，销毁等等影响逻辑。两个例子，1. 依赖ui的文本值作为数据，万一需求变为通过动画显示文本值，那么动画期间无法获取本该有的值。2. 依赖ui生命周期或事件触发数据相关的变化，ui在隐藏时无法监听事件，导致数据无法更新。
18. 接口理解加深：1.使用上，接口一定是为了a调起b时，这个b将来可能是多个类的实例对象，a作为调用者，作为主动方，只需要知道b的功能，不限制b是具体的什么类，也就是说将来好几个类都有这个功能，但他们又不属于同一个类。这时为了给a服务好，a就定义好这个约束条件。换句话说，如果定义的接口仅仅只有一个类实现，那么就没必要使用接口了。 2. 抽象层解耦，当a调用b的功能时，如果不使用接口，a必须要显示的引入具体的b类，这样a和b就有了强耦合，接口从抽象层解除了ab的连接，具体可以在运行时动态决定。 3. 多人开发时，可以提前定义好接口，方便多功能同时开发，类似于客户端，服务端之间定义的协议。
19. 状态机理解：基于当前环境和输入动作，做出对应的反应，类似于生命对外界刺激做出响应。每个状态本身都是稳定的，用简单的状态切换来替代复杂的逻辑判断过程。这种设计更多是对某个对象的行为的抽象。


