1. 算法思想汇总：核心：分而治之，化整为零，化繁为简（包括时间空间），  缓存，递归，贪心局部最优。相似的功能块抽象为类；区分对象的相同与不同；
  解决问题思路：对于一般性的抽象问题，可以先从特殊解出发简化问题，掌握规律后，再回归一般。即 一般=>特殊=>一般
2. 抽象类与接口分别： 使用上是否支持多继承等。更核心的是设计目的区别：抽象类为了避免重复代码； 接口是为了体现约束关系；
3. 同一对象复杂功能的实现，不要深层次的继承。拆分为子组件，用零件挂载实现更好。
4. 模块之间不要有很明显的引用关系，防止复用模块或改名改路径时，导致引用报错
5. 全局对象有创建，一定要有销毁。对象完整生命周期管理，对全局有影响的操作 例如：定时器， requestAnimationFrame，事件监听等，都要考虑不用时的移除。
6. 不管数据结构，逻辑关系，一定要剪除任何多余的，没有用到的，摩棱两可的，可有可无的东西，即使现在没有问题，将来扩展时一定会出问题；
7. 设计任何一个类 结构 东西时。都不应该把它设置的太孤立了，不要唯一性。要随时可以创造出与之平级的兄弟元素。就是说设计不能太死了，将来有可能有类似的模块。（这条只是感觉，现在没有具体说明）
8. https://blog.csdn.net/weixin_40121676/article/details/105717756?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai
9. 数据管理经验：对于复杂的对象数组数据类型，可能在多个地方需要使用，如果直接对其引用，会让管理混乱，可能在不知道的地方对原始值进行了修改；如果直接拷贝后，又会有多个备份不能及时同步的风险；正确做法应该时，在一个地方保存，然后利用简单类型（number,string）作为数据特征加到单条数据中，通过get**方法获取。
10. 装饰器是对原先的 类 属性 方法 的扩展，在装饰 类 上面为了能缓解继承的复杂度，没必要已扩展就继承，可能导致层级太深。
11. 设计结构种的通信标准：总体来说，相互独立性较强的模块之间使用事件通信，完全解耦。模块内部联系较强，可以用回调，父子组件，或者功能组件种依赖原则应该顺其自然为，具体依赖抽象，子组件依赖父组件，内部依赖外部，因为真正运行时的主动权的都是最末端，最具体的功能。越往上层越要兼顾的更多，所以整体不可能去绑定某个具体部分，整体，外层，抽象的更像是指定约束，或是工具引用。
12. 前端ui显示流程，为了更清晰的分开视图和数据，应设计为分两步进行，第一步将不依赖数据静态内容加载渲染出来，相当于有一个ui骨架，完成后派发出一个时间节点，ui加载完成，同时发起数据请求，收到相应后，使用对应的数据刷新ui。


