# 目标
实际需求总是复杂多变无序的。根据化繁为简的思想。应该将其整理成不同的简单有序小模块。怎样设计这些小模块及让小模块之间能共同完成完整功能，更加具体的设计的目标是：
1. 分离，复用：  
    修改时能不影响原先其他的业务所以需要分离，相同的修改只改一处所以需要复用。
2. 统一结构：  
    让维护时能通过自上至下的层级快速清晰的定位业务模块。


# 模块划分
## 按实现方式 
模块实现上其实有个矛盾点： 分离的越彻底，依赖性越少，独立性越强，但是想强调内在联系，统一性就越难，
1. 纵向的封装继承：  
    继承的设计目的是提取可复用的代码。适用于两个模块之间会有大量的重复代码，这些重复的功能能抽象成一个与模块关系较为紧密的父类。继承的方式强调两个模块之间虽然分离但是同属一脉的联系。所以偏向于脚本层面的类与类的组织方式
2. 横向的组件化，模块化：  
    组件强调两个模块纯粹的没有内在联系的分离，都处于某个整体本不相干的部分，彼此之间通过接口，事件等连线交流，对两方来说，对面的功能是黑盒子。所以偏向用于功能层面的组织方式。
## 按模块内容
1. ui工具  
    脱离数据的纯ui工具，模块很小，使用频率高。例如：下拉框，导航栏，滚动列表等。
2. 业务模块  
    真正实现需求的模块，模块内部包括视图，数据，业务三种内容，模块内部需要把三要素组织起来向外提供功能。下面讨论的都是这种独立的业务模块

#  三要素： 
- **V-视图view**：单纯的显示效果ui结构，或者纯ui动作，不是指某个ui结构的实例，动作中的回调不会直接执行而是将生命周期向外暴露，判断标准为去掉这部不会影响逻辑正常运行。ui插槽是可移除的才算真正的被分离。
- **D-数据data**：包括服务器业务数据，客户端的临时数据等，但不包括纯ui数据，这里的数据指的是具体的数据，而不是某个数据结构
- **L-业务逻辑logic**：一般是数据加工处理，数据转接映射，流程把控


# 模块间关系
复杂的功能由各个独立的小模块组织完成，它们之间的关系无非三种，包含，相交，相离。
- 包含和相离没有区别，各自的三要素互相独立，通过接口，事件相互通信。
- 相交的情况，指两个模块的三要素部分相交，可以共用  

两个不同的模块的VDL之间，有可能出现下列六种情况：分别讨论
1. V相同，DL不同：  
    相同的ui结构， 数据与逻辑不一样，
2. D相同，VL不同：
3. L相同，VD不同：
4. V不同，DL相同：
5. D不同，VL相同：
6. L不同，VD相同：
